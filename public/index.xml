<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GopherBOOk</title>
    <link>http://gopherbook.iris-go.com/index.xml</link>
    <description>Recent content on GopherBOOk</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://gopherbook.iris-go.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hello World</title>
      <link>http://gopherbook.iris-go.com/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/hello-world/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-hello-world&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Hello World&lt;/h1&gt;

&lt;p&gt;This example will show how to start a webserver on port 8080 and print the classic &amp;ldquo;hello world&amp;rdquo; message.&lt;/p&gt;

&lt;p&gt;For this we have to actually &lt;a target=&#34;_blank&#34; href=&#34;https://golang.org/doc/articles/go_command.html#tmp_3&#34;&gt;go get&lt;/a&gt; the popular &lt;a target=&#34;_blank&#34; href=&#34;https://github.com/kataras/iris&#34;&gt;kataras/iris&lt;/a&gt; library like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get gopkg.in/kataras/iris.v6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From now on, every application we write will be able to make use of this library!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// hello-world.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
)

func main() {
    app := iris.New()
    // Adapt the &amp;quot;httprouter&amp;quot;, faster,
    // but it has limits on named path parameters&#39; validation,
    // you can adapt &amp;quot;gorillamux&amp;quot; if you need regexp path validation!
    app.Adapt(httprouter.New())

    app.HandleFunc(&amp;quot;GET&amp;quot;, &amp;quot;/&amp;quot;, func(ctx *iris.Context) {
        ctx.Writef(&amp;quot;hello world\n&amp;quot;)
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run hello-world.go

$ curl -s http://localhost:8080/
hello world
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Routes (using httprouter)</title>
      <link>http://gopherbook.iris-go.com/routes-using-httprouter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/routes-using-httprouter/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-routes-using-httprouter&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Routes (using httprouter)&lt;/h1&gt;

&lt;p&gt;This example will show how to register routes using the popular &lt;a target=&#34;_blank&#34; href=&#34;https://github.com/julienschmidt/httprouter&#34;&gt;httprouter&lt;/a&gt; router.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// routes.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
)

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())

    userAges := map[string]int{
        &amp;quot;Alice&amp;quot;:  25,
        &amp;quot;Bob&amp;quot;:    30,
        &amp;quot;Claire&amp;quot;: 29,
    }

    // Equivalent with app.HandleFunc(&amp;quot;GET&amp;quot;, ...)
    app.Get(&amp;quot;/users/:name&amp;quot;, func(ctx *iris.Context) {
        name := ctx.Param(&amp;quot;name&amp;quot;)
        age := userAges[name]

        ctx.Writef(&amp;quot;%s is %d years old!&amp;quot;, name, age)
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run routes.go

$ curl -s http://localhost:8080/users/Bob
Bob is 30 years old!
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Routes (using gorillamux)</title>
      <link>http://gopherbook.iris-go.com/routes-using-gorillamux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/routes-using-gorillamux/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-routes-using-gorillamux&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Routes (using gorillamux)&lt;/h1&gt;

&lt;p&gt;This example will show how to register routes using the popular &lt;a target=&#34;_blank&#34; href=&#34;https://github.com/gorilla/mux&#34;&gt;gorillamux&lt;/a&gt; router.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// routes.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/gorillamux&amp;quot;
)

func main() {
    app := iris.New()
    // Adapt the &amp;quot;httprouter&amp;quot;, you can use &amp;quot;gorillamux&amp;quot; too.
    app.Adapt(gorillamux.New())

    userAges := map[string]int{
        &amp;quot;Alice&amp;quot;:  25,
        &amp;quot;Bob&amp;quot;:    30,
        &amp;quot;Claire&amp;quot;: 29,
    }

    // Equivalent with app.HandleFunc(&amp;quot;GET&amp;quot;, ...)
    app.Get(&amp;quot;/users/{name}&amp;quot;, func(ctx *iris.Context) {
        name := ctx.Param(&amp;quot;name&amp;quot;)
        age := userAges[name]

        ctx.Writef(&amp;quot;%s is %d years old!&amp;quot;, name, age)
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run routes.go

$ curl -s http://localhost:8080/users/Bob
Bob is 30 years old!
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Templates</title>
      <link>http://gopherbook.iris-go.com/templates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/templates/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-templates&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Templates&lt;/h1&gt;

&lt;p&gt;This example will show how to render a simple list of TODO items into an html page using the &lt;code&gt;html/template view adaptor&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Iris supports 5 template engines out-of-the-box, you can still use any external golang template engine,
as &lt;code&gt;context.ResponseWriter&lt;/code&gt; is an &lt;code&gt;io.Writer&lt;/code&gt; and &lt;code&gt;http.ResponseWriter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All of these five template engines have common features with common API,
like Layout, Template Funcs, Party-specific layout, partial rendering and more.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  The standard html, based on github.com/kataras/go-template/tree/master/html
  its template parser is the golang.org/pkg/html/template/.

  Django, based ongithub.com/kataras/go-template/tree/master/django
  its template parser is the github.com/flosch/pongo2

  Pug(Jade), based on github.com/kataras/go-template/tree/master/pug
  its template parser is the github.com/Joker/jade

  Handlebars, based on github.com/kataras/go-template/tree/master/handlebars
  its template parser is the github.com/aymerick/raymond

  Amber, based on github.com/kataras/go-template/tree/master/amber
  its template parser is the github.com/eknkc/amber
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;View engine is the &lt;code&gt;adaptors/view&lt;/code&gt; package.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;standard html  | view.HTML(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;django         | view.Django(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;pug(jade)      | view.Pug(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;handlebars     | view.Handlebars(&amp;hellip;)&lt;/li&gt;
&lt;li&gt;amber          | view.Amber(&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;// todos.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/view&amp;quot;
)

// Todo bind struct
type Todo struct {
    Task string
    Done bool
}

func main() {
    // Configuration is optional
    app := iris.New(iris.Configuration{Gzip: false, Charset: &amp;quot;UTF-8&amp;quot;})

    // Adapt a logger which will print all errors to os.Stdout
    app.Adapt(iris.DevLogger())

    // Adapt the httprouter (we will use that on all examples)
    app.Adapt(httprouter.New())

    // Parse all files inside `./mytemplates` directory ending with `.html`
    app.Adapt(view.HTML(&amp;quot;./mytemplates&amp;quot;, &amp;quot;.html&amp;quot;))

    todos := []Todo{
        {&amp;quot;Learn Go&amp;quot;, true},
        {&amp;quot;Read GopherBOOk&amp;quot;, true},
        {&amp;quot;Create a web app in Go&amp;quot;, false},
    }

    app.Get(&amp;quot;/&amp;quot;, func(ctx *iris.Context) {
        ctx.Render(&amp;quot;todos.html&amp;quot;, struct{ Todos []Todo }{todos})
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- mytemplates/todos.html --&amp;gt;
&amp;lt;h1&amp;gt;Todos&amp;lt;/h1&amp;gt;
&amp;lt;ul&amp;gt;
    {{range .Todos}}
        {{if .Done}}
            &amp;lt;li&amp;gt;&amp;lt;s&amp;gt;{{.Task}}&amp;lt;/s&amp;gt;&amp;lt;/li&amp;gt;
        {{else}}
            &amp;lt;li&amp;gt;{{.Task}}&amp;lt;/li&amp;gt;
        {{end}}
    {{end}}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run todos.go
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;demo&#34;&gt;
    &lt;h1&gt;Todos&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;s&gt;Learn Go&lt;/s&gt;&lt;/li&gt;
        &lt;li&gt;&lt;s&gt;Read Go Web Examples&lt;/s&gt;&lt;/li&gt;
        &lt;li&gt;Create a web app in Go&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Forms</title>
      <link>http://gopherbook.iris-go.com/forms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/forms/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-forms&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Forms&lt;/h1&gt;

&lt;p&gt;This example will show how to simulate a contact form and parse the message into a struct.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// forms.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/view&amp;quot;
)

// ContactDetails the information from user
type ContactDetails struct {
    Email   string
    Subject string
    Message string
}

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())

    // Parse all files inside `./mytemplates` directory ending with `.html`
    app.Adapt(view.HTML(&amp;quot;./mytemplates&amp;quot;, &amp;quot;.html&amp;quot;))

    app.Get(&amp;quot;/&amp;quot;, func(ctx *iris.Context) {
        ctx.Render(&amp;quot;forms.html&amp;quot;, nil)
    })

    // Equivalent with app.HandleFunc(&amp;quot;POST&amp;quot;, ...)
    app.Post(&amp;quot;/&amp;quot;, func(ctx *iris.Context) {

        // details := ContactDetails{
        //  Email:   ctx.FormValue(&amp;quot;email&amp;quot;),
        //  Subject: ctx.FormValue(&amp;quot;subject&amp;quot;),
        //  Message: ctx.FormValue(&amp;quot;message&amp;quot;),
        // }

        // or simply:
        var details ContactDetails
        ctx.ReadForm(&amp;amp;details)
        
        // do something with details
        _ = details

        ctx.Render(&amp;quot;forms.html&amp;quot;, struct{ Success bool }{true})
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- mytemplates/forms.html --&amp;gt;
{{if .Success}}
    &amp;lt;h1&amp;gt;Thanks for your message!&amp;lt;/h1&amp;gt;
{{else}}
    &amp;lt;h1&amp;gt;Contact&amp;lt;/h1&amp;gt;
    &amp;lt;form method=&amp;quot;POST&amp;quot;&amp;gt;
        &amp;lt;label&amp;gt;Email:&amp;lt;/label&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;email&amp;quot;&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;label&amp;gt;Subject:&amp;lt;/label&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;subject&amp;quot;&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;label&amp;gt;Message:&amp;lt;/label&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;textarea name=&amp;quot;message&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
{{end}}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run forms.go
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;demo&#34;&gt;
    &lt;h1&gt;Contact&lt;/h1&gt;
    &lt;form method=&#34;POST&#34;&gt;
        &lt;label&gt;Email:&lt;/label&gt;&lt;br /&gt;
        &lt;input type=&#34;text&#34; name=&#34;email&#34;&gt;&lt;br /&gt;
        &lt;label&gt;Subject:&lt;/label&gt;&lt;br /&gt;
        &lt;input type=&#34;text&#34; name=&#34;subject&#34;&gt;&lt;br /&gt;
        &lt;label&gt;Message:&lt;/label&gt;&lt;br /&gt;
        &lt;textarea name=&#34;message&#34;&gt;&lt;/textarea&gt;&lt;br /&gt;
        &lt;input type=&#34;submit&#34;&gt;
    &lt;/form&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>http://gopherbook.iris-go.com/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/json/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-json&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; JSON&lt;/h1&gt;

&lt;p&gt;This example will show how to encode and decode JSON data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// json.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
)

// User bind struct
type User struct {
    Firstname string `json:&amp;quot;firstname&amp;quot;`
    Lastname  string `json:&amp;quot;lastname&amp;quot;`
    Age       int    `json:&amp;quot;age&amp;quot;`
}

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())

    app.Post(&amp;quot;/decode&amp;quot;, func(ctx *iris.Context) {
        var user User
        ctx.ReadJSON(&amp;amp;user)

        ctx.Writef(&amp;quot;%s %s is %d years old!&amp;quot;, user.Firstname, user.Lastname, user.Age)
    })

    app.Get(&amp;quot;/encode&amp;quot;, func(ctx *iris.Context) {
        peter := User{
            Firstname: &amp;quot;John&amp;quot;,
            Lastname:  &amp;quot;Doe&amp;quot;,
            Age:       25,
        }

        ctx.JSON(iris.StatusOK, peter)
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run json.go

$ curl -s -XPOST -d&#39;{&amp;quot;firstname&amp;quot;:&amp;quot;Donald&amp;quot;,&amp;quot;lastname&amp;quot;:&amp;quot;Trump&amp;quot;,&amp;quot;age&amp;quot;:70}&#39; http://localhost:8080/decode
Donald Trump is 70 years old!

$ curl -s http://localhost:8080/encode
{&amp;quot;firstname&amp;quot;:&amp;quot;John&amp;quot;,&amp;quot;lastname&amp;quot;:&amp;quot;Doe&amp;quot;,&amp;quot;age&amp;quot;:25}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Static Files</title>
      <link>http://gopherbook.iris-go.com/static-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/static-files/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-static-files&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Static Files&lt;/h1&gt;

&lt;p&gt;This example will show how to serve static files like CSSs, JavaScripts or images from a specific directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// static-files.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
)

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())
    // first parameter is the request path
    // second is the operating system directory
    app.StaticWeb(&amp;quot;/static&amp;quot;, &amp;quot;./assets&amp;quot;)

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ tree assets/
assets/
└── css
    └── styles.css
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run static-files.go

$ curl -s http://localhost:8080/static/css/styles.css
body {
    background-color: black;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Upload Files</title>
      <link>http://gopherbook.iris-go.com/upload-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/upload-files/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-upload-files&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Upload Files&lt;/h1&gt;

&lt;p&gt;This example will show how to upload files to a specific directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// upload-files.go
package main

import (
    &amp;quot;crypto/md5&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;strconv&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/view&amp;quot;
)

func main() {
    app := iris.New()
    app.Adapt(iris.DevLogger())
    app.Adapt(httprouter.New())
    app.Adapt(view.HTML(&amp;quot;./templates&amp;quot;, &amp;quot;.html&amp;quot;))

    // Serve the form.html to the user
    app.Get(&amp;quot;/upload&amp;quot;, func(ctx *iris.Context) {
        //create a token (optionally)

        now := time.Now().Unix()
        h := md5.New()
        io.WriteString(h, strconv.FormatInt(now, 10))
        token := fmt.Sprintf(&amp;quot;%x&amp;quot;, h.Sum(nil))
        //render the form with the token for any use you like
        ctx.Render(&amp;quot;upload_form.html&amp;quot;, token)
    })

    // Handle the post request from the upload_form.html to the server
    app.Post(&amp;quot;/upload&amp;quot;, iris.LimitRequestBodySize(10&amp;lt;&amp;lt;20),
        func(ctx *iris.Context) {
            // or use ctx.SetMaxRequestBodySize(10 &amp;lt;&amp;lt; 20)
            //to limit the uploaded file(s) size.

            // Get the file from the request
            file, info, err := ctx.FormFile(&amp;quot;uploadfile&amp;quot;)

            if err != nil {
                ctx.HTML(iris.StatusInternalServerError,
                    &amp;quot;Error while uploading: &amp;lt;b&amp;gt;&amp;quot;+err.Error()+&amp;quot;&amp;lt;/b&amp;gt;&amp;quot;)
                return
            }

            defer file.Close()
            fname := info.Filename

            // Create a file with the same name
            // assuming that you have a folder named &#39;uploads&#39;
            out, err := os.OpenFile(&amp;quot;./uploads/&amp;quot;+fname,
                os.O_WRONLY|os.O_CREATE, 0666)

            if err != nil {
                ctx.HTML(iris.StatusInternalServerError,
                    &amp;quot;Error while uploading: &amp;lt;b&amp;gt;&amp;quot;+err.Error()+&amp;quot;&amp;lt;/b&amp;gt;&amp;quot;)
                return
            }
            defer out.Close()

            io.Copy(out, file)
        })

    // start the server at 127.0.0.1:8080
    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ tree ./
templates/
└── upload_form.html
uploads/
└──
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run upload-files.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Upload file&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form enctype=&#34;multipart/form-data&#34;
        action=&#34;http://127.0.0.1:8080/upload&#34; method=&#34;post&#34;&gt;
        &lt;input type=&#34;file&#34; name=&#34;uploadfile&#34; /&gt; &lt;input type=&#34;hidden&#34;
            name=&#34;token&#34; value=&#34;{{.}}&#34; /&gt; &lt;input type=&#34;submit&#34; value=&#34;upload&#34; /&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Favicon</title>
      <link>http://gopherbook.iris-go.com/favicon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/favicon/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-favicon&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Favicon&lt;/h1&gt;

&lt;p&gt;This example will show how to serve a favicon for your page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// favicon.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
)

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())
    // This will serve the ./static/favicons/iris_favicon_32_32.ico to: localhost:8080/favicon.ico
    app.Favicon(&amp;quot;./static/favicons/iris_favicon_32_32.ico&amp;quot;)

    // app.Favicon(&amp;quot;./static/favicons/iris_favicon_32_32.ico&amp;quot;, &amp;quot;/favicon_32_32.ico&amp;quot;)
    // This will serve the ./static/favicons/iris_favicon_32_32.ico to: localhost:8080/favicon_32_32.ico

    app.Get(&amp;quot;/&amp;quot;, func(ctx *iris.Context) {
        ctx.HTML(iris.StatusOK, `You should see the favicon now at the side of your browser,
      if not, please refresh or clear the browser&#39;s cache.`)
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ tree ./
favicon.go
static/
└── favicons
    └── iris_favicon_32_32.ico
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run favicon.go
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Password Hashing</title>
      <link>http://gopherbook.iris-go.com/password-hashing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/password-hashing/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-password-hashing&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Password Hashing&lt;/h1&gt;

&lt;p&gt;This example will show how to hash passwords using bcrypt.
For this we have to &lt;code&gt;go get&lt;/code&gt; the golang bcrypt library like so:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ go get golang.org/x/crypto/bcrypt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;From now on, every application we write will be able to make use of this library.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// passwords.go
package main

import (
    &amp;quot;fmt&amp;quot;

    &amp;quot;golang.org/x/crypto/bcrypt&amp;quot;
)

func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
    return string(bytes), err
}

func CheckPasswordHash(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

func main() {
    password := &amp;quot;secret&amp;quot;
    hash, _ := HashPassword(password) // ignore error for the sake of simplicity

    fmt.Println(&amp;quot;Password:&amp;quot;, password)
    fmt.Println(&amp;quot;Hash:    &amp;quot;, hash)

    match := CheckPasswordHash(password, hash)
    fmt.Println(&amp;quot;Match:   &amp;quot;, match)
}


&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run passwords.go
Password: secret
Hash:     $2a$14$ajq8Q7fbtFRQvXpdCq7Jcuy.Rx1h/L4J60Otx.gyNLbAYctGMJ9tK
Match:    true
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sessions</title>
      <link>http://gopherbook.iris-go.com/sessions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/sessions/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-sessions&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Sessions&lt;/h1&gt;

&lt;p&gt;This example will show how to store data from a session.&lt;/p&gt;

&lt;p&gt;You don&amp;rsquo;t need any third-party library except Iris, but if you want you can use anything, remember Iris is fully compatible with the standard library. You can find a more detailed example by pressing &lt;a href=&#34;https://github.com/kataras/iris/blob/v6/adaptors/sessions/_example/main.go&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this example we will only allow authenticated users to view our secret message on the &lt;code&gt;/secret&lt;/code&gt; page. To get access to it, the will first have to visit &lt;code&gt;/login&lt;/code&gt; to get a valid session cookie, which logs him in. Additionally he can visit &lt;code&gt;/logout&lt;/code&gt; to revoke his access to our secret message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// sessions.go
package main

import (
    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/sessions&amp;quot;
)

var (
    key = &amp;quot;my_sessionid&amp;quot;
)

func secret(ctx *iris.Context) {

    // Check if user is authenticated
    if auth, _ := ctx.Session().GetBoolean(&amp;quot;authenticated&amp;quot;); !auth {
        ctx.EmitError(iris.StatusForbidden)
        return
    }

    // Print secret message
    ctx.WriteString(&amp;quot;The cake is a lie!&amp;quot;)
}

func login(ctx *iris.Context) {
    session := ctx.Session()

    // Authentication goes here
    // ...

    // Set user as authenticated
    session.Set(&amp;quot;authenticated&amp;quot;, true)
}

func logout(ctx *iris.Context) {
    session := ctx.Session()

    // Revoke users authentication
    session.Set(&amp;quot;authenticated&amp;quot;, false)
}

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())

    sess := sessions.New(sessions.Config{Cookie: key})
    app.Adapt(sess)

    app.Get(&amp;quot;/secret&amp;quot;, secret)
    app.Get(&amp;quot;/login&amp;quot;, login)
    app.Get(&amp;quot;/logout&amp;quot;, logout)

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run sessions.go

$ curl -s http://localhost:8080/secret
Forbidden

$ curl -s -I http://localhost:8080/login
Set-Cookie: mysessionid=MTQ4NzE5Mz...

$ curl -s --cookie &amp;quot;mysessionid=MTQ4NzE5Mz...&amp;quot; http://localhost:8080/secret
The cake is a lie!
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Websockets</title>
      <link>http://gopherbook.iris-go.com/websockets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/websockets/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-websockets&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Websockets&lt;/h1&gt;

&lt;p&gt;This example will show how to work with websockets in Go. We will build a simple server which echoes back everything we send to it.
You don&amp;rsquo;t need any third-party library except &lt;code&gt;adaptors/websocket&lt;/code&gt;, but if you want you can use anything. Remember: Iris is fully compatible with the standard library.&lt;/p&gt;

&lt;p&gt;You can find more websocket examples by pressing &lt;a href=&#34;https://github.com/kataras/iris/tree/v6/adaptors/websocket/_examples&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// websockets.go
package main

import (
    &amp;quot;fmt&amp;quot;

    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/websocket&amp;quot;
)

func handleConnection(c websocket.Connection) {

    // Read events from browser
    c.On(&amp;quot;chat&amp;quot;, func(msg string) {

        // Print the message to the console
        fmt.Printf(&amp;quot;%s sent: %s\n&amp;quot;, c.Context().RemoteAddr(), msg)

        // Write message back to browser
        c.Emit(&amp;quot;chat&amp;quot;, msg)
    })

}

func main() {
    app := iris.New()
    app.Adapt(httprouter.New())

    // create our echo websocket server
    ws := websocket.New(websocket.Config{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        Endpoint:        &amp;quot;/echo&amp;quot;,
    })

    ws.OnConnection(handleConnection)

    // Adapt the websocket server.
    // you can adapt more than one of course.
    app.Adapt(ws)

    app.Get(&amp;quot;/&amp;quot;, func(ctx *iris.Context) {
        ctx.ServeFile(&amp;quot;websockets.html&amp;quot;, false) // second parameter: enable gzip?
    })

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- websockets.html --&amp;gt;
&amp;lt;input id=&amp;quot;input&amp;quot; type=&amp;quot;text&amp;quot; /&amp;gt;
&amp;lt;button onclick=&amp;quot;send()&amp;quot;&amp;gt;Send&amp;lt;/button&amp;gt;
&amp;lt;pre id=&amp;quot;output&amp;quot;&amp;gt;&amp;lt;/pre&amp;gt;
&amp;lt;script src=&amp;quot;/iris-ws.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var input = document.getElementById(&amp;quot;input&amp;quot;);
    var output = document.getElementById(&amp;quot;output&amp;quot;);

    // Ws comes from the auto-served &#39;/iris-ws.js&#39;
    var socket = new Ws(&amp;quot;ws://localhost:8080/echo&amp;quot;);
    socket.OnConnect(function () {
        output.innerHTML += &amp;quot;Status: Connected\n&amp;quot;;
    });

    socket.OnDisconnect(function () {
        output.innerHTML += &amp;quot;Status: Disconnected\n&amp;quot;;
    });

    // read events from the server
    socket.On(&amp;quot;chat&amp;quot;, function (msg) {
        output.innerHTML += &amp;quot;Server: &amp;quot; + msg + &amp;quot;\n&amp;quot;;
    });

    function send() {
        // send chat event data to the server
        socket.Emit(&amp;quot;chat&amp;quot;, input.value);
        input.value = &amp;quot;&amp;quot;;
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run websockets.go
[127.0.0.1]:53403 sent: Hello Go Web Examples, you&#39;re doing great!
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;demo&#34;&gt;
    &lt;input type=&#34;text&#34;&gt;
    &lt;button&gt;Send&lt;/button&gt;
    &lt;pre&gt;Status: Connected
Server: Hello Go Web Examples, you&#39;re doing great!&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Render Markdown and Cache Handler</title>
      <link>http://gopherbook.iris-go.com/cache-markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/cache-markdown/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-render-markdown-and-cache-handler&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Render Markdown and Cache Handler&lt;/h1&gt;

&lt;p&gt;This example will show how to send Markdown contents and use the Cache handler to cache the handler&amp;rsquo;s response.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file markdown-cache.go
package main

import (
    &amp;quot;time&amp;quot;

    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
)

var testMarkdownContents = `## Hello Markdown

This is a sample of Markdown contents



Features
--------

All features of Sundown are supported, including:

*   **Compatibility**. The Markdown v1.0.3 test suite passes with
    the --tidy option.  Without --tidy, the differences are
    mostly in whitespace and entity escaping, where blackfriday is
    more consistent and cleaner.

*   **Common extensions**, including table support, fenced code
    blocks, autolinks, strikethroughs, non-strict emphasis, etc.

*   **Safety**. Blackfriday is paranoid when parsing, making it safe
    to feed untrusted user input without fear of bad things
    happening. The test suite stress tests this and there are no
    known inputs that make it crash.  If you find one, please let me
    know and send me the input that does it.

    NOTE: &amp;quot;safety&amp;quot; in this context means *runtime safety only*. In order to
    protect yourself against JavaScript injection in untrusted content, see
    [this example](https://github.com/russross/blackfriday#sanitize-untrusted-content).

*   **Fast processing**. It is fast enough to render on-demand in
    most web applications without having to cache the output.

*   **Thread safety**. You can run multiple parsers in different
    goroutines without ill effect. There is no dependence on global
    shared state.

*   **Minimal dependencies**. Blackfriday only depends on standard
    library packages in Go. The source code is pretty
    self-contained, so it is easy to add to any project, including
    Google App Engine projects.

*   **Standards compliant**. Output successfully validates using the
    W3C validation tool for HTML 4.01 and XHTML 1.0 Transitional.

    [this is a link](https://github.com/kataras/iris) `

func main() {
    app := iris.New()
    // output startup banner and error logs on os.Stdout
    app.Adapt(iris.DevLogger())
    // set the router, you can choose gorillamux too
    app.Adapt(httprouter.New())

    app.Get(&amp;quot;/hi&amp;quot;, app.Cache(func(c *iris.Context) {
        c.WriteString(&amp;quot;Hi this is a big content, do not try cache on small content it will not make any significant difference!&amp;quot;)
    }, time.Duration(10)*time.Second))

    bodyHandler := func(ctx *iris.Context) {
        ctx.Markdown(iris.StatusOK, testMarkdownContents)
    }

    expiration := time.Duration(5 * time.Second)

    app.Get(&amp;quot;/&amp;quot;, app.Cache(bodyHandler, expiration))

    // if expiration is &amp;lt;=time.Second then the cache tries to set the expiration from the &amp;quot;cache-control&amp;quot; maxage header&#39;s value(in seconds)
    // // if this header doesn&#39;t founds then the default is 5 minutes
    app.Get(&amp;quot;/cache_control&amp;quot;, app.Cache(func(ctx *iris.Context) {
        ctx.HTML(iris.StatusOK, &amp;quot;&amp;lt;h1&amp;gt;Hello!&amp;lt;/h1&amp;gt;&amp;quot;)
    }, -1))

    app.Listen(&amp;quot;:8080&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run markdown-cache.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Hello Markdown&lt;/h2&gt;

&lt;p&gt;This is a sample of Markdown contents&lt;/p&gt;

&lt;h2&gt;Features&lt;/h2&gt;

&lt;p&gt;All features of Sundown are supported, including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Compatibility&lt;/strong&gt;. The Markdown v1.0.3 test suite passes with
the &amp;ndash;tidy option.  Without &amp;ndash;tidy, the differences are
mostly in whitespace and entity escaping, where blackfriday is
more consistent and cleaner.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Common extensions&lt;/strong&gt;, including table support, fenced code
blocks, autolinks, strikethroughs, non-strict emphasis, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Safety&lt;/strong&gt;. Blackfriday is paranoid when parsing, making it safe
to feed untrusted user input without fear of bad things
happening. The test suite stress tests this and there are no
known inputs that make it crash.  If you find one, please let me
know and send me the input that does it.&lt;/p&gt;

&lt;p&gt;NOTE: &amp;ldquo;safety&amp;rdquo; in this context means &lt;em&gt;runtime safety only&lt;/em&gt;. In order to
protect yourself against JavaScript injection in untrusted content, see
&lt;a href=&#34;https://github.com/russross/blackfriday#sanitize-untrusted-content&#34;&gt;this example&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Fast processing&lt;/strong&gt;. It is fast enough to render on-demand in
most web applications without having to cache the output.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Thread safety&lt;/strong&gt;. You can run multiple parsers in different
goroutines without ill effect. There is no dependence on global
shared state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Minimal dependencies&lt;/strong&gt;. Blackfriday only depends on standard
library packages in Go. The source code is pretty
self-contained, so it is easy to add to any project, including
Google App Engine projects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Standards compliant&lt;/strong&gt;. Output successfully validates using the
W3C validation tool for HTML 4.01 and XHTML 1.0 Transitional.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kataras/iris&#34;&gt;this is a link&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Online Visitors</title>
      <link>http://gopherbook.iris-go.com/online-visitors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/online-visitors/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-online-visitors&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; Online Visitors&lt;/h1&gt;

&lt;p&gt;This example will show how to do an online visitors system per-page.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// file online-visitors.go
package main

import (
    &amp;quot;sync/atomic&amp;quot;

    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/view&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/websocket&amp;quot;
)

var (
    app *iris.Framework
    ws  websocket.Server
)

func init() {
    // init the server instance
    app = iris.New()
    // adapt a logger in dev mode
    app.Adapt(iris.DevLogger())
    // adapt router
    app.Adapt(httprouter.New())
    // adapt templaes
    app.Adapt(view.HTML(&amp;quot;./templates&amp;quot;, &amp;quot;.html&amp;quot;).Reload(true))
    // adapt websocket
    ws = websocket.New(websocket.Config{Endpoint: &amp;quot;/my_endpoint&amp;quot;})
    ws.OnConnection(HandleWebsocketConnection)
    app.Adapt(ws)
}

type page struct {
    PageID string
}

func main() {
    app.StaticWeb(&amp;quot;/js&amp;quot;, &amp;quot;./static/assets/js&amp;quot;)

    h := func(ctx *iris.Context) {
        ctx.Render(&amp;quot;index.html&amp;quot;, page{PageID: &amp;quot;index page&amp;quot;})
    }

    h2 := func(ctx *iris.Context) {
        ctx.Render(&amp;quot;other.html&amp;quot;, page{PageID: &amp;quot;other page&amp;quot;})
    }

    // Open some browser tabs/or windows
    // and navigate to
    // http://localhost:8080/ and http://localhost:8080/other
    // Each page has its own online-visitors counter.
    app.Get(&amp;quot;/&amp;quot;, h)
    app.Get(&amp;quot;/other&amp;quot;, h2)
    app.Listen(&amp;quot;:8080&amp;quot;)
}

type pageView struct {
    source string
    count  uint64
}

func (v *pageView) increment() {
    atomic.AddUint64(&amp;amp;v.count, 1)
}

func (v *pageView) decrement() {
    oldCount := v.count
    if oldCount &amp;gt; 0 {
        atomic.StoreUint64(&amp;amp;v.count, oldCount-1)
    }
}

func (v *pageView) getCount() uint64 {
    val := atomic.LoadUint64(&amp;amp;v.count)
    return val
}

type (
    pageViews []pageView
)

func (v *pageViews) Add(source string) {
    args := *v
    n := len(args)
    for i := 0; i &amp;lt; n; i++ {
        kv := &amp;amp;args[i]
        if kv.source == source {
            kv.increment()
            return
        }
    }

    c := cap(args)
    if c &amp;gt; n {
        args = args[:n+1]
        kv := &amp;amp;args[n]
        kv.source = source
        kv.count = 1
        *v = args
        return
    }

    kv := pageView{}
    kv.source = source
    kv.count = 1
    *v = append(args, kv)
}

func (v *pageViews) Get(source string) *pageView {
    args := *v
    n := len(args)
    for i := 0; i &amp;lt; n; i++ {
        kv := &amp;amp;args[i]
        if kv.source == source {
            return kv
        }
    }
    return nil
}

func (v *pageViews) Reset() {
    *v = (*v)[:0]
}

var v pageViews

// HandleWebsocketConnection handles the online viewers per example(gist source)
func HandleWebsocketConnection(c websocket.Connection) {

    c.On(&amp;quot;watch&amp;quot;, func(pageSource string) {
        v.Add(pageSource)
        // join the socket to a room linked with the page source
        c.Join(pageSource)

        viewsCount := v.Get(pageSource).getCount()
        if viewsCount == 0 {
            viewsCount++ // count should be always &amp;gt; 0 here
        }
        c.To(pageSource).Emit(&amp;quot;watch&amp;quot;, viewsCount)
    })

    c.OnLeave(func(roomName string) {
        if roomName != c.ID() { // if the roomName  it&#39;s not the connection iself
            // the roomName here is the source, this is the only room(except the connection&#39;s ID room) which we join the users to.
            pageV := v.Get(roomName)
            if pageV == nil {
                return // for any case that this room is not a pageView source
            }
            // decrement -1 the specific counter for this page source.
            pageV.decrement()
            // 1. open 30 tabs.
            // 2. close the browser.
            // 3. re-open the browser
            // 4. should be  v.getCount() = 1
            // in order to achieve the previous flow we should decrement exactly when the user disconnects
            // but emit the result a little after, on a goroutine
            // getting all connections within this room and emit the online views one by one.
            // note:
            // we can also add a time.Sleep(2-3 seconds) inside the goroutine at the future if we don&#39;t need &#39;real-time&#39; updates.
            go func(currentConnID string) {
                for _, conn := range ws.GetConnectionsByRoom(roomName) {
                    if conn.ID() != currentConnID {
                        conn.Emit(&amp;quot;watch&amp;quot;, pageV.getCount())
                    }

                }
            }(c.ID())
        }

    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// file static/assets/js/visitors.js
(function() {
  var socket = new Ws(&amp;quot;ws://localhost:8080/my_endpoint&amp;quot;);

  socket.OnConnect(function () {
      socket.Emit(&amp;quot;watch&amp;quot;, PAGE_SOURCE);
  });


  socket.On(&amp;quot;watch&amp;quot;, function (onlineViews) {
      var text = &amp;quot;1 online view&amp;quot;;
      if (onlineViews &amp;gt; 1) {
          text = onlineViews + &amp;quot; online views&amp;quot;;
      }
      document.getElementById(&amp;quot;online_views&amp;quot;).innerHTML = text;
  });

  socket.OnDisconnect(function () {
    document.getElementById(&amp;quot;online_views&amp;quot;).innerHTML = &amp;quot;you&#39;ve been disconnected&amp;quot;;
  });

})();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- file ./templates/index.html --&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Online visitors example&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            margin: 0;
            font-family: -apple-system, &amp;quot;San Francisco&amp;quot;, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;Noto&amp;quot;, &amp;quot;Roboto&amp;quot;, &amp;quot;Calibri Light&amp;quot;, sans-serif;
            color: #212121;
            font-size: 1.0em;
            line-height: 1.6;
        }

        .container {
            max-width: 750px;
            margin: auto;
            padding: 15px;
        }

        #online_views {
            font-weight: bold;
            font-size: 18px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;span id=&amp;quot;online_views&amp;quot;&amp;gt;1 online view&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
      /* take the page source from our passed struct  on .Render */
      var PAGE_SOURCE = {{ .PageID }}
    &amp;lt;/script&amp;gt;

    &amp;lt;script src=&amp;quot;/iris-ws.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script src=&amp;quot;/js/visitors.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- file ./templates/other.html --&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Different page, different results&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        #online_views {
            font-weight: bold;
            font-size: 18px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

    &amp;lt;span id=&amp;quot;online_views&amp;quot;&amp;gt;1 online view&amp;lt;/span&amp;gt;


    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
      /* take the page source from our passed struct  on .Render */
      var PAGE_SOURCE = {{ .PageID }}
    &amp;lt;/script&amp;gt;

    &amp;lt;script src=&amp;quot;/iris-ws.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script src=&amp;quot;/js/visitors.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ tree ./
online-visitors.go
static/
└── assets/
        └──js/
           └── visitors.js
templates/
└── index.html
└── other.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run online-visitors.go
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>URL Shortener</title>
      <link>http://gopherbook.iris-go.com/url-shortener/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://gopherbook.iris-go.com/url-shortener/</guid>
      <description>

&lt;h1 id=&#34;go-web-examples-url-shortener&#34;&gt;&lt;a href=&#34;http://gopherbook.iris-go.com/&#34;&gt;Go Web Examples:&lt;/a&gt; URL Shortener&lt;/h1&gt;

&lt;p&gt;This example will show how to make a simple URL Shortener.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// url-shortener.go
package main

import (
    &amp;quot;html/template&amp;quot;
    &amp;quot;math/rand&amp;quot;
    &amp;quot;net/url&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;gopkg.in/kataras/iris.v6&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/httprouter&amp;quot;
    &amp;quot;gopkg.in/kataras/iris.v6/adaptors/view&amp;quot;
)

func main() {
    app := iris.New()
    app.Adapt(
        iris.DevLogger(),
        httprouter.New(),
        view.HTML(&amp;quot;./templates&amp;quot;, &amp;quot;.html&amp;quot;).Reload(true),
    )

    // Serve static files (css)
    app.StaticWeb(&amp;quot;/static&amp;quot;, &amp;quot;./static_files&amp;quot;)

    var mu sync.Mutex
    var urls = map[string]string{
        &amp;quot;iris&amp;quot;: &amp;quot;http://support.iris-go.com&amp;quot;,
    }

    app.Get(&amp;quot;/&amp;quot;, func(ctx *iris.Context) {
        ctx.Render(&amp;quot;index.html&amp;quot;, iris.Map{&amp;quot;url_count&amp;quot;: len(urls)})
    })

    // find and execute a short url by its key
    // used on http://localhost:8080/url/dsaoj41u321dsa
    execShortURL := func(ctx *iris.Context, key string) {
        if key == &amp;quot;&amp;quot; {
            ctx.EmitError(iris.StatusBadRequest)
            return
        }

        value, found := urls[key]
        if !found {
            ctx.SetStatusCode(iris.StatusNotFound)
            ctx.Writef(&amp;quot;Short URL for key: &#39;%s&#39; not found&amp;quot;, key)
            return
        }

        ctx.Redirect(value, iris.StatusTemporaryRedirect)
    }
    app.Get(&amp;quot;/url/:shortkey&amp;quot;, func(ctx *iris.Context) {
        execShortURL(ctx, ctx.Param(&amp;quot;shortkey&amp;quot;))
    })

    //  for wildcard subdomain (yeah.. cool) http://dsaoj41u321dsa.localhost:8080
    // Note:
    // if you want subdomains (chrome doesn&#39;t works on localhost, so you have to define other hostname on app.Listen)
    // app.Party(&amp;quot;*.&amp;quot;, func(ctx *iris.Context) {
    //  execShortURL(ctx, ctx.Subdomain())
    // })

    app.Post(&amp;quot;/url/shorten&amp;quot;, func(ctx *iris.Context) {
        data := make(map[string]interface{}, 0)
        data[&amp;quot;url_count&amp;quot;] = len(urls)
        value := ctx.FormValue(&amp;quot;url&amp;quot;)
        if value == &amp;quot;&amp;quot; {
            data[&amp;quot;form_result&amp;quot;] = &amp;quot;You need to a enter a URL.&amp;quot;
        } else {
            urlValue, err := url.ParseRequestURI(value)
            if err != nil {
                // ctx.JSON(iris.StatusInternalServerError,
                //  iris.Map{&amp;quot;status&amp;quot;: iris.StatusInternalServerError,
                //      &amp;quot;error&amp;quot;:  err.Error(),
                //      &amp;quot;reason&amp;quot;: &amp;quot;Invalid URL&amp;quot;,
                //  })
                data[&amp;quot;form_result&amp;quot;] = &amp;quot;Invalid URL.&amp;quot;
            } else {
                key := randomString(12)
                // Make sure that the key is unique
                for {
                    if _, exists := urls[key]; !exists {
                        break
                    }
                    key = randomString(8)
                }
                mu.Lock()
                urls[key] = urlValue.String()
                mu.Unlock()
                ctx.SetStatusCode(iris.StatusOK)
                shortenURL := &amp;quot;http://&amp;quot; + app.Config.VHost + &amp;quot;/url/&amp;quot; + key
                data[&amp;quot;form_result&amp;quot;] = template.HTML(&amp;quot;&amp;lt;pre&amp;gt;Here is your short URL: &amp;lt;a href=&#39;&amp;quot; + shortenURL + &amp;quot;&#39;&amp;gt;&amp;quot; + shortenURL + &amp;quot; &amp;lt;/a&amp;gt;&amp;lt;/pre&amp;gt;&amp;quot;)
            }

        }
        ctx.Render(&amp;quot;index.html&amp;quot;, data)
    })

    app.Listen(&amp;quot;localhost:8080&amp;quot;)
}

//  +------------------------------------------------------------+
//  |                                                            |
//  |                      Random String                         |
//  |                                                            |
//  +------------------------------------------------------------+

const (
    letterBytes   = &amp;quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;
    letterIdxBits = 6                    // 6 bits to represent a letter index
    letterIdxMask = 1&amp;lt;&amp;lt;letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
    letterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits
)

func randomString(n int) string {
    src := rand.NewSource(time.Now().UnixNano())
    b := make([]byte, n)
    // A src.Int63() generates 63 random bits, enough for letterIdxMax characters!
    for i, cache, remain := n-1, src.Int63(), letterIdxMax; i &amp;gt;= 0; {
        if remain == 0 {
            cache, remain = src.Int63(), letterIdxMax
        }
        if idx := int(cache &amp;amp; letterIdxMask); idx &amp;lt; len(letterBytes) {
            b[i] = letterBytes[idx]
            i--
        }
        cache &amp;gt;&amp;gt;= letterIdxBits
        remain--
    }

    return string(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;/* static_files/style.css */
body{
    background-color:silver;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- templates/index.html --&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Golang URL Shortener&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/static/css/style.css&amp;quot; /&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;Golang URL Shortener&amp;lt;/h2&amp;gt;
    &amp;lt;h3&amp;gt;{{ .form_result}}&amp;lt;/h3&amp;gt;
    &amp;lt;form action=&amp;quot;/url/shorten&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;url&amp;quot; style=&amp;quot;width: 35em;&amp;quot; /&amp;gt;
        &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Shorten!&amp;quot; /&amp;gt;
    &amp;lt;/form&amp;gt;

    &amp;lt;p&amp;gt;{{ .url_count }} URLs shortened&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ tree ./
url-shortener.go
templates/
└── index.html
static_files/
└── css
    └── styles.css
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run url-shortener.go
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>